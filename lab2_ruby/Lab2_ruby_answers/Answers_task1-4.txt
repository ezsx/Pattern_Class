TASK1____________________________________________________Вопросы:
# #
# #     a.
# #   Что такое класс, что такое объект, как создать объект класса?
# #     b.
# #   В чем заключается принцип инкапсуляции? Как получить
# #   доступ к полям объекта из внешнего класса?
# #     c.
# #   Как используются символы для решения задач инкапсуляции
# #   и уменьшения количества кода при описании класса?
# #     d.
# #   Что такое конструктор, зачем он нужен, как описывается
# #   конструктор в произвольном классе?
# #     e.
# #   Опишите механизм создания объекта.
# #     f.
# #   Что такое метод класса, в чем его отличие от метода объекта?
# #     g.
# #   Приведите два практических примера, когда введение метода класса вы
# #   считаете необходимым согласно концепциям ООП.
# #
# # Ответы на вопросы:
# #
# #   а. Класс — это план или шаблон для создания объектов. Объект является экземпляром
# #   класса и представляет конкретный экземпляр класса. Чтобы создать объект класса,
# #   вы сначала определяете класс, а затем используете newметод для создания объекта этого класса.
# #
# #   б. Принцип инкапсуляции означает, что внутренние детали объекта должны быть скрыты от
# #   внешнего мира и доступны только через общедоступный интерфейс. Чтобы получить доступ
# #   к полям объекта из внешнего класса, вы можете использовать методы получения и установки,
# #   которые позволяют вам извлекать или изменять значения полей.
# #
# #   в. Символы используются для решения проблем инкапсуляции и уменьшения объема кода при
# #   описании класса, выступая в качестве сокращения для именования переменных и методов.
# #   Они неизменяемы и могут использоваться в качестве ключей в хэшах, что делает их более
# #   эффективным и удобочитаемым способом определения атрибутов и методов в классе.
# #
# #   д. Конструктор — это специальный метод, который автоматически вызывается при создании объекта.
# #   Он используется для инициализации объекта и установки его начального состояния.
# #   Конструктор описывается в классе путем определения метода с тем же именем, что и у класса.
# #   Конструктор может принимать аргументы для инициализации полей объекта.
# #
# #   е. Механизм создания объекта заключается в использовании new метода класса.
# #   Метод new создает новый экземпляр класса и возвращает ссылку на объект.
# #   Вы можете передать аргументы new методу для инициализации полей объекта.
# #
# #   ф. Метод класса — это метод, который определен на уровне класса и может вызываться в самом классе,
# #   а не в экземпляре класса. Метод класса отличается от метода объекта, который определен на уровне объекта
# #   и может быть вызван для экземпляра класса.
# #
# #   г. Два практических примера использования метода класса:
# #
# #   Когда вам нужно выполнить операцию, не зависящую от состояния какого-либо отдельного объекта,
# #   например вспомогательную функцию, которую можно использовать во всем коде.
# #
# #   Когда вам нужно создать объект из метода класса, а не вне класса, например,
# #   когда вы хотите создать одноэлементный класс, который гарантирует существование
# #   только одного экземпляра класса.

TASK2____________________________________________________Вопросы:
# #
# # a.
# # Опишите структуру классов языка Ruby, как в нее вписывается написанный Вами класс?
# # b.
# # Опишите принцип наследования, переопределение методов и
# # способы вызова переопределенного метода.
# # c.
# # Опишите принципы работы конструкторов для наследуемых классов.
# # d.
# # Какие методы объекта обязательно есть у любого написанного
# # Вами класса, опишите, что они делают.
#
# # Ответы на вопросы:
#
# #   а. Структура классов языка Ruby основана на парадигме объектно-ориентированного программирования,
# #   где классы определяют поведение и свойства объектов. Классы могут наследовать от других классов,
# #   что позволяет им повторно использовать и расширять поведение существующих классов.
# #
# #   Класс, который был написан в предыдущем ответе, Student вписывается в эту структуру как базовый класс,
# #   определяющий свойства и поведение объекта ученика.
# #
# #   б. Принцип наследования в Ruby позволяет классам наследовать свойства и поведение родительского класса.
# #   Это означает, что дочерний класс может получать доступ и использовать методы и атрибуты родительского класса,
# #   а также может добавлять новые методы или переопределять методы родительского класса.
# #
# #   Переопределение методов в Ruby можно выполнить с помощью def ключевого слова, за которым следует имя метода
# #   и его реализация. Когда метод переопределяется в дочернем классе, говорят, что он «переопределен».
# #
# #   Чтобы вызвать переопределенный метод в дочернем классе, вы можете использовать super ключевое слово.
# #   Это ключевое слово позволяет вызывать исходную реализацию метода, определенного в родительском классе.
# #
# #   в. В Ruby конструкторы — это именованные методы initialize, которые автоматически вызываются при создании объекта.
# #   Когда класс наследуется от другого класса, дочерний класс может иметь свой собственный initialize метод,
# #   который можно использовать для установки свойств объекта.
# #
# #   При создании объекта дочернего класса initialize сначала будет вызываться метод дочернего класса,
# #   а затем метод родительского класса initialize. Это позволяет дочернему классу устанавливать свои
# #   собственные свойства, а также наследовать свойства, установленные родительским классом.
# #
# #   д. Каждый класс в Ruby должен иметь хотя бы один метод-конструктор с именем initialize, который используется
# #   для инициализации свойств объекта.
# #
# #   Кроме того, класс должен иметь методы, определяющие его поведение. В Student классе get_info метод
# #   возвращает краткую информацию об ученике, например его фамилию и инициалы, Git и ссылку.
# #
# #   Методы read_from_txt и write_to_txt используются для чтения и записи данных в текстовый файл соответственно.
# #   Эти методы позволяют сохранять данные и могут использоваться для хранения и извлечения данных между различными
# #   экземплярами программы.



TASK3____________________________________________________Вопросы:

    a. Опишите принцип инкапсуляции на примере написанных
классов, объясните наличие или отсутствие геттеров и сеттеров для
каждого из полей разработанных Вами классов.

    b. Опишите, в каком случае необходимо использовать паттерн
Шаблон. Опишите его преимущества и недостатки.

    c. В чем заключается принцип подстановки?

    d. Напишите на листочке пример рефакторинга на основании
паттерна Шаблонный.

а. Инкапсуляция — это принцип объектно-ориентированного программирования,
который позволяет группировать данные и поведение в один объект.
В разработанных классах инкапсуляция достигается за счет того, что поля класса
становятся закрытыми и предоставляются общедоступные методы для доступа к этим полям и управления ими.
Таким образом, класс может контролировать доступ к своим данным и управление ими,
гарантируя, что данные остаются в согласованном состоянии. Геттеры и сеттеры — это методы,
позволяющие получать доступ к полям и управлять ими соответственно. В разработанных классах геттеры присутствуют
для всех полей, а сеттеры присутствуют только для тех полей, которые необходимо изменить. Это обеспечивает
больший контроль над тем, как обрабатываются данные, и помогает предотвратить непреднамеренные изменения данных.

б. Шаблон шаблона используется, когда у вас есть общий алгоритм, который может использоваться несколькими классами.
Общий алгоритм определяется в суперклассе, а затем подклассы могут при необходимости переопределять определенные
части алгоритма. Преимущества использования этого шаблона включают повторное использование кода и возможность
добавления новых функций в систему без необходимости модификации существующего кода. Недостатки включают
увеличение количества классов и необходимость тщательного планирования и проектирования, чтобы гарантировать,
что общий алгоритм четко определен и что подклассы правильно переопределяют необходимые части.

в. Принцип подстановки гласит, что любой объект производного класса может быть заменен объектом его
базового класса без каких-либо непредвиденных последствий. Это означает, что объекты производных классов
можно использовать везде, где используются объекты базового класса, если производный класс реализует все
необходимые методы базового класса.

д. Примером рефакторинга, основанного на шаблоне шаблона, является перенос класса, содержащего общий алгоритм,
в новый суперкласс. Затем исходный класс становится подклассом суперкласса и может при необходимости переопределять
определенные части алгоритма. Это позволяет повторно использовать код и упрощает добавление новых функций в систему,
поскольку общий алгоритм может быть обновлен в суперклассе без необходимости изменения существующих подклассов.

TASK4____________________________________________________Вопросы:
a. Опишите, как Вы понимаете утверждение – Используйте
делегацию вместо наследования, напишите на бумаге
тривиальный пример.
b. Что такое отношение ассоциации в ОПП? Покажите
разновидности ассоциации.
c. Опишите проблему и место применения паттерна
стратегия, как пример делегации.
d. Напишите на бумаге или на доске тривиальный пример
наследования и реализации паттерна стратегия, объясните
разницу.
e. Приведите пример ситуации, когда нет необходимости в
применении паттерна.


а. Утверждение «Использовать делегирование вместо наследования» означает, что вместо наследования поведения и
свойств от родительского класса лучше делегировать поведение другому объекту. Это обеспечивает большую гибкость
и возможность повторного использования, поскольку делегированный объект может быть изменен в любое время,
не затрагивая исходный объект.

Например, рассмотрим класс «Птица», у которого есть метод «летать». Вместо создания подкласса «Пингвин»,
который наследует класс «Птица» и переопределяет метод «летать» для создания исключения, мы можем делегировать
поведение «полет» другому объекту «Летун». Класс «Пингвин» теперь может иметь экземпляр класса «Летчик»,
который может иметь собственный метод «летать», не позволяющий пингвину летать. Таким образом, поведение можно
изменить в будущем, не затрагивая исходный класс «Птица».

б. Отношение ассоциации в OPP — это отношение между двумя классами, где один класс связан с другим классом.
Эта связь может принимать несколько форм, включая агрегацию, композицию и наследование.

Агрегация — это слабая форма ассоциации, когда один класс может иметь несколько экземпляров другого класса,
но не владеет им. Например, класс «Отдел» может иметь несколько экземпляров класса «Сотрудник», но сотрудники
могут существовать вне отдела.

Композиция — это более сильная форма ассоциации, когда один класс состоит из нескольких экземпляров другого
класса и не может существовать без него. Например, класс «Автомобиль» состоит из нескольких экземпляров класса
«Колесо» и не может существовать без колес.

Наследование — это особая форма ассоциации, при которой один класс наследует свойства и поведение другого класса.
Например, класс «Кошка» может наследоваться от класса «Животное» и иметь те же свойства и поведение, что и животное.

в. Шаблон стратегии используется, когда необходимо переключаться между различными алгоритмами или стратегиями во
время выполнения. Проблема, которую он решает, заключается в наличии нескольких алгоритмов или стратегий для решения
конкретной проблемы и необходимости иметь возможность переключаться между ними в зависимости от ситуации. Шаблон
стратегии делегирует поведение отдельному объекту стратегии, обеспечивая большую гибкость и повторное использование.

Например, рассмотрим класс «Сжатие», которому необходимо сжимать данные с использованием разных алгоритмов.
Вместо большого оператора switch или набора операторов if-else в коде мы можем делегировать поведение сжатия
отдельному объекту стратегии. Таким образом, если нам нужно добавить новый алгоритм сжатия, мы можем просто
создать новый объект стратегии, не затрагивая исходный класс «Сжатие».

д. В случае наследования подкласс наследует свойства и поведение родительского класса. В случае шаблона
стратегии поведение делегируется отдельному объекту стратегии.

Например, давайте рассмотрим класс «Утка», которому нужно выполнять различные типы кряканий. В случае
наследования мы можем создать разные подклассы для каждого типа шарлатана (например, «Кряква», «Резиноваяутка»).
В случае шаблона стратегии мы можем делегировать крякающее поведение отдельным объектам стратегии (например, «Крякать», «Пискнуть»).
Класс «Утка» может иметь экземпляр соответствующего объекта стратегии, что позволяет нам изменять
поведение шарлатана в любое время, не затрагивая исходный класс «Утка».

е.Примером ситуации, когда нет необходимости применять шаблон,
является ситуация, когда задача проста и может быть решена без использования шаблонов проектирования.
Например, при создании простого приложения, которое только отображает информацию, может не понадобиться использовать шаблон стратегии.
В таком сценарии достаточно использовать простые операторы if-else или операторы switch-case
для обработки различных сценариев и не гарантирует использование более сложного шаблона проектирования.
Кроме того, использование шаблонов проектирования может усложнить код и усложнить его поддержку,
поэтому важно использовать их только при необходимости.
